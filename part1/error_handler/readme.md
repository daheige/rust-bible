# 异常的分类
- 可恢复异常是用户和环境与程序交互时预期会发生的异常。例如文件未找到（file not found）或数字解析错误。
- 不可恢复异常是违反契约或程序常量的异常，例如索引越界或除以零的操作（分母是零）。
- 致命性异常是立即让程序终止运行的异常。这种情况包括内存不足和堆栈溢出

# 错误处理的2种方式
- 关于错误处理的两种非常流行的范式是返回代码和异常
- 通过异常来实现的。诸如 Java 和 C#之类的高级编程语言就
  是采用这种方式处理错误的。在这种范式中，可能出错的代码应该包含在 try 代码块中，try
  代码块中的任何错误都必须在 catch 代码块中捕获。（理想情况下，在 try 代码块之后就应
  该立即使用 catch 代码块。）但是异常也有其不足，抛出异常的开销是很昂贵的，因为程序
  必须展开堆栈，找到适当的异常处理程序，并运行相关的代码
- 为了避免这种开销，程序员经常采用防御性代码的形式检查抛出异常的代码，再继续执行其他操作。此外，异常的
  实现在许多语言中都存在缺陷，因为它允许新手使用基础异常类（例如 Java 中的 throwable）
  捕获所有代码块的异常，如果它们只是记录并忽略该异常，那么可能导致程序中的状态不
  一致。此外，在这些语言中，程序员无法通过查看代码来了解方法是否可以抛出异常，除
  非他们使用带有检查异常的方法。这使得程序员很难编写出安全的代码。因此，开发者经
  常需要依赖方法的说明文档（如果有的话）来确定是否可以抛出异常

# rust 为什么选择错误处理异常呢
在 Rust 中，返回值表示适当的异常类型，并且支持用户自定义类型。语言的类型系统要求在编译时处理错
误状态。如果你了解 Haskell，这与它的 Maybe 和 Either 类型相似，Rust 只是提供的名称不
同，即可恢复错误的 Option 和 Result 类型。对于不可恢复错误，有一种被称为 panic 的机
制，它是一种灾难性故障处理机制，当程序中存在错误或破坏常量的情况时，建议将其用作最后的处理措施。
- 异常及其相关的堆栈展开会产生开销。这与 Rust 的零运行时成本的核心理念相悖。
- 其次，异常式的错误处理（通常是其典型实现）允许通过 catch-all 异常处理程序忽略这些错误。这可能会造成程序状态的不一致，
违背 Rust 的安全性原则。

# rust中panic!不可恢复的错误
    panic!时进程默认开始展开（unwinding）、回溯栈并清理函数据
    如果希望二进制文档尽量小，可以选择“终止（abort）”，
    此时进程内存由操作系统进行清理

    展开：展开是从其遇到的每个函数的堆栈存储器中清除数据的过程。
    但是, 展开过程需要大量工作。展开的替代方法是中止
    终止：是在不清除堆栈存储器中数据的情况下结束程序的过程。
    操作系统将删除数据。如果我们从平缓切换到终止, 那么我们需要添加以下语句：
    [profile]
    panic='abort'
    
    [profile.release]
    panic='abort'

# RUST_BACKTRACE 可以追踪堆栈信息
    设置 RUST_BACKTRACE 环境变量来得到一个 backtrace backtrace 
    是一个执行到目前位置所有被调 用的函数的列表。Rust 的 backtrace 
    跟其他语言中的一样：阅读 backtrace 的关键是从头开始读直到发现你编写的文件

# rust错误处理方式
关于panic！和 Result<T,E> 错误传播处理的选择:
- 对于一些启动或读取配置文件，这种可以panic!,程序必须终止的时候
- 对于一些错误处理可交给上游业务方处理的话，就建议使用Result + ?错误传播的方式，让调用者自己来决定
- 对于不会发生的错误，可以使用unwrap(),expect("xxx")来处理
- panic!,unwrap(),expect这三个，如果在多个线程中处理，仅仅只会影响当前线程，不会发生跨线程的panic

# rust错误的小结
- Rust 的错误处理功能被设计为帮助你编写更加健壮的代码。
- panic! 宏代表一个程序无法处理的状态，并停止执行而不是使用无效或不正确的值继续处理。
- Rust 类型系统的 Result 枚举代表操作可能会在一种可以恢复的情况下失败。
- 可以使 用 Result 来告诉代码调用者他需要处理潜在的成功或失败。
- 在适当的场景使用 panic! 和 Result 将会使你的代码在面对无处不在的错误时显得更加可靠。
