# 内存管理和安全性
## 进程的内存布局
![图片](https://github.com/daheige/rust-bible/assets/9988859/b1235eab-6338-4ae6-8d3d-387bebc3e92e)

- 文本段：此部分包含已编译的二进制文件中执行的实际代码。文本段是只读的，禁止任何用户代码对其进行修改。因为这样做可能导致程序崩溃。
- 数据段：它会进一步细分，即初始化数据段和未初始化数据段，后者通常被称为以符号开始的块（Block Started by Symbol，BSS），并保存程序中声明的所有全局和静态值。未初始化的值在加载到内存时会被初始化为零。
- 堆栈段：该部分用于保存任何局部变量和函数的返回地址。预先知道大小的所有资源，以及程序创建的任何临时/中间变量都隐式存储在堆栈中。
- 堆片段：该部分用于存储任何动态分配的数据，这些数据的大小是未知的，并且可以根据程序的需要在运行时进行更改。当我们希望值的寿命比声明它的函数更长时，这是比较理想的方式。

## 程序如何使用内存
### 如何访问此内存来执行相关任务呢？
`出于安全性和故障隔离方面的考虑，不允许进程直接访问物理内存，而是使用虚拟内存，操作系统使用被称为页面的内存数据结构映射到实际的物理内存，这些数据结构在页面表中维护。进程必须从操作系统请求内存供其使用，它获得的是一个内部映射到随机存取存储器（Random Access Memory，RAM）物理地址的虚拟地址。出于性能方面的考虑，内存都以块为单位被请求和处理。当进程访问虚拟内存时，内存管理单元执行从虚拟内存到物理内存的实际转换。`

## 内存分配和取消分配
进程从操作系统获取内存的一系列步骤称为内存分配。进程通过使用来自操作系统的
系统调用请求内存块，操作系统会标记该进程正在使用的内存块。当使用该内存的进程执
行完毕时，它必须将内存标记为空闲的，以便其他进程可以使用该内存。这被称为内存的
取消分配。
主流的操作系统实现通过系统调用（例如 Linux 中的 brk 和 sbrk）提供抽象，这些函数直接与操作系统内核对话并分配进程请求的内存。但是这些内核级函数是非常低级的，因此它们会被系统库进一步抽象，例如 glibc 库，它是 Linux 中的 C 标准库，其中包括 POSIX API 的实现，通过 C 语言实现与操作系统底层的交互。

# 内存分配的位置
在程序运行时，进程中的内存分配既可能发生在堆栈上，也可能发生在堆上。它们是存储地址，用于存储程序执行过程中用到的数值。
堆栈用于处理在编译期已知大小的短期值，这是函数调用及其关联上下文的理想存储位置，一旦函数返回，它就需要被清理掉。
堆用于处理任何需要超出函数调用范围的内容。
`默认情况下，Rust 偏向于使用堆栈分配内存。通常，你创建并绑定到变量的任何类型的值或实例都会存储到堆栈中。存储到堆上是显式的，可以通过智能指针类型来实现。`


## 内存管理及其分类
+ 手动型：C 语言采用了这种内存管理机制，且完全由程序员负责，在程序代码使用完内存之后调用 free 函数来释放内存。C++在某种程度上使用智能指针自动执行此操作，其中 free 函数调用放在类的析构函数定义中。Rust 也有智能指针。
+ 自动型：采用这种内存管理形式的语言包括一个额外的运行时线程，即 GC，它作为守护线程与程序一起运行。诸如 Python、Java、GO、C#及 Ruby 等大部分基于虚拟机的动态语言都依赖+ 自动化内存管理。自动化内存管理是使用这些语言编写代码很容易的原因之一。
+ 半自动型：Swift 等语言属于这一类别。它们没有作为运行时的一部分的内置专用GC，但提供了引用计数类型，这可以细粒度地实现自动化内存管理。Rust 也提供了引用计数类型 Rc<T>和 Arc<T>。

## 堆栈
无论何时调用函数或方法，堆栈都用于为函数内部创建的值分配空间。函数中所有 let
绑定都存储在堆栈中，它既可以是值本身，也可以是指向堆上内存地址的指针。这些值构
成了活动函数的堆栈帧。堆栈帧是堆栈中存储器的逻辑块，用于存储函数调用的上下文。
此上下文可能包括函数参数、局部变量、返回地址，以及从函数返回后需要恢复的任何已
保存的寄存器值。随着越来越多的函数被调用，它们对应的堆栈帧会被压入堆栈。
一旦函数返回，与之相关的堆栈帧，以及其中声明的所有值都会一起被清理释放。
这些值会根据它们声明的相反顺序删除，并且遵循后进先出（Last In First Out，LIFO）
规则。

`堆栈上内存分配速度很快，因为分配和释放内存只需一条 CPU 指令：递增/递减堆栈帧指针。
堆栈帧指针（esp）是一个 CPU 寄存器，它始终指向堆栈的最顶部。`堆栈帧指针在函数被调用或返回时实时更新。`当函数返回时，通过将堆栈帧指针恢复到进入函数之前的位置来丢弃该堆栈帧。使用堆栈是一种临时性内存分配策略，但由于其简单性，它在释放已使用内存方面是可靠的。但是，堆栈的相同属性不适用于需要超出当前堆栈帧生命周期的情况`

## 堆
堆用于处理更复杂的动态的内存分配需求。`程序可能在某个时点在堆上分配内存，并且可能在某个其他时点释放，同时这些时点之间不存在严格的边界，就像堆栈内存一样。`
`在堆栈上分配内存时，你能够确定分配和释放内存的时机。此外，堆中的值可能存活得比分配给它的函数更久，稍后也可能会被其他函数清理、释放。在这种情况下，代码无法调用 free 函数，因此最糟糕的情况可能是根本无法取消分配。`

不同语言使用堆内存的方式也不尽相同。在 Python 等动态语言中，一切都是对象，默
认情况下它们都会在堆上分配内存。在 C 语言中，我们使用手动调用 malloc 函数的方式在
堆上分配内存，而在 C++中，我们使用关键字 new 分配内存。要释放内存，我们需要在 C语言中调用 free 函数，而在 C++中调用 delete 函数。`在 C++中，为了避免手动调用 delete函数，程序员经常使用诸如 unique_ptr 或 shared_ptr 这样的智能指针类型。这些智能指针类
型具有析构方法，当它们超出内部作用域时，会调用 delete 函数。这种管理内存的范式被称为 RAII 原则，并由 C++推而广之。`

Rust 对 C++管理堆内存的机制也提供了类似的抽象。`Rust 在堆上分配内存的唯一方法是通过智能指针类型。Rust 中的智能指针类型实现了 Drop特征，它指定了如何释放值所使用的内存，并且在语义上定义了类似于 C++中析构函数的方法。除非用户编写自定义的智能指针类型，否则你永远不需要在其类型上实现 Drop 特征。`

`为了在堆上分配内存，语言依赖于专用的内存分配器，它隐藏了所有底层细节`，例如在已对齐的内存上分配内存，维护空闲的内存块以减少系统调用开销，并在分配内存和其他优化时减少碎片的产生。`对于编译程序，编译器 rustc 自身会采用 jemalloc 内存分配器，而从 Rust 构建的库和二进制文件会使用系统内存分配器。`在 Linux 上，依赖的将是 glibc
内存分配器 API。jemalloc 是一个支持多线程环境的高效内存分配器库，它大大减少了 Rust程序的构建时间。`虽然编译器采用了jemalloc，但是任何使用 Rust 构建的应用程序都不会使用它，因为它会增加二进制文件的大小。`因此，已编译的二进制文件和库默认情况下都会采用系统内存分配器。

`在 Rust 中，大部分事先不知道尺寸的动态类型都在堆上分配内存。不过这不包括基元类型。`例如，在堆上创建一个 String 对象:
```rust
let s =String::new("daheige");
```
String::new 会在堆上分配一个 Vec<u8>类型，并返回对它的引用。此引用会和变量 s绑定，该变量在堆栈上分配内存。只要 s 在作用域范围内，堆中的字符串就会一直存在。
当 s 超出其作用域时，Vec<u8>将会从堆中释放，其 drop 方法将作为 Drop 实现的一部分进行调用。`对于需要在堆上为基元类型分配内存的极个别情况，可以使用 Box<T>类型，它是一种泛型智能指针类型。`

## 内存管理的缺陷
- `在使用 GC 的语言中，可将处理内存的工作从程序员那里抽离出来。你可以在代码中声明和使用变量，不过如何释放它们并不需要你去操心`。
- 另一方面，`底层的系统编程语言（例如 C/C++）无法将这些细节与程序员隔离，并且几乎不提供任何安全性。`这里，程序员负责通过手动调用 free 函数来释放内存，如果我们看一下与内存管理有关的当前软件中常见的漏洞和暴露（Common Vulnerabilities & Exposure，CVE），就会发现我们对此并不擅长！
- `程序员可以通过错误的顺序分配和释放值来轻易构造出难以调试的错误，这些错误甚至可能是由于忘记释放已使用的内存或非法转换指针导致的。`在 C 语言中，没有什么可以阻止你创建一个指向整数的指针，若在某处取消对它的引用，会导致程序在运行时崩溃。此外，由于编译器检查较少，因此在 C 语言中创建漏洞非常容易。
- `最令人担忧的情况是释放在堆上分配的数据。堆内存需要谨慎使用，如果没有释放，堆中的值可能在程序的生命周期中永久存在，并且最终会导致应用程序被内核中的内存越界（Out Of Memory，OOM）守护程序终结。`在运行时，会由代码中的错误或开发人员的错误而导致忘记释放内存，或者访问超出内存布局之外的地方，以及在受保护的代码段中取消引用的内存地址。发生这种情况时，进程会从内核接收陷阱指令，这时我们将看到分段错误的异常信息，然后进程被终止。

因此，我们必须确保进程与内存的交互安全性。作为程序员我们必须谨小慎微地对待 malloc 和 free 函数调用，或者使用内存安全的语言为我们处理这些细节。

## 内存安全性
`内存安全性是指你的程序永远不会访问它不应该访问的位置，程序中声明的变量不能指向无效内存，并且在所有代码路径中都保持有效。`换句话说，`安全性基本上会归结为在程序中始终具有有效引用的指针，并且使用指针的操作不会导致未定义的行为。`未定义的行为指程序的状态出现了编译器未考虑到
的情况，因为编译器规范中没有说明在该情况下会发生什么。
内存不安全性的另一个示例是 C 语言中的缓冲区溢出。以下用一段简单的代码来演示此问题:
```c
int main() { 
 char buf[3]; 
 buf[0] = 'a'; 
 buf[1] = 'b'; 
 buf[2] = 'c'; 
 buf[3] = 'd'; 
}
```
上述程序能够通过编译，并在没有错误的情况下运行，但是最后一次赋值操作越过了分配的缓冲区，且可能覆盖其他数据或地址中的指令。此外，兼容架构和环境的特定恶意输入值可能会导致任意代码执行。这些错误在实际代码中以非常隐蔽的方式产生，并可能产生线上漏洞。在最新版本的 GCC 编译器中，这会被检测为堆栈粉碎攻击，GCC 会通过发送 SIGABRT(abort)信号来将程序挂起。
`内存安全性 bug 会导致内存泄漏，以分段错误的形式导致程序崩溃，或者在最糟糕的情况下产生安全漏洞。要在 C 语言中创建正确且安全的程序，程序员必须在使用完内存后进行适当的 free 函数调用。`
如今的 C++通过智能指针类型来处理与手动内存管理有关的问题，但这并不能完全消除它们。
java使用垃圾收集机制来消除所有和类有关的内存安全问题。
`虽然Rust没有内置GC，但由于该语言中采用了相同的RAII
原则，同时根据变量的作用域为我们自动释放使用过的内存，因此比 C/C++更安全`

## rust程序存放数据的内存区域
Rust 程序有 3 个存放数据的内存区域:
- 数据内存 - 对于固定大小和静态（即在整个程序生命周期中都存在）的数据。 考虑一下程序中的文本（例如 “Hello World”），该文本的字节只能读取，因此它们位于该区域中。 编译器对这类数据做了很多优化，由于位置已知且固定，因此通常认为编译器使用起来非常快。
- 栈内存 - 对于在函数中声明为变量的数据。 在函数调用期间，内存的位置不会改变，因为编译器可以优化代码，所以栈数据使用起来比较快。
- 堆内存 - 对于在程序运行时创建的数据。 此区域中的数据可以添加、移动、删除、调整大小等。由于它的动态特性，通常认为它使用起来比较慢， 但是它允许更多创造性的内存使用。当数据添加到该区域时，我们称其为分配。 从本区域中删除 数据后，我们将其称为释放。

## rust内存安全三原则
`所有权、借用和生命周期，让Rust能够在编译期检测程序中内存安全违规，在离开作用域时自动释放相关资源等情况。`
所有权有点类似核心原则，而借用和生命周期是对语言类型系统的扩展。在代码的不同上下文中加强或有时放松所有权原则，可确保编译期内存管理正常运作。
