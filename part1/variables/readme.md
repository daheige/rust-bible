# 数据类型
类型分为：基本数据类型和复合类型
- 基本数据类型：
    - 数值类型: 有符号整数 (i8, i16, i32, i64, isize)
            无符号整数 (u8, u16, u32, u64, usize) 
            浮点数 (f32, f64)、以及有理数、复数
    - 字符串：字符串字面量、字符串切片&str和堆分配字符串String
    - 布尔类型： bool true和false
    - 字符类型: 表示单个Unicode字符，存储为4个字节,比如说'a','b'
    - 元类型: 即()，其唯一的值也是()

- 元类型
    - 元类型就是()，对，你没看错，就是()，唯一的值也是()
    没错，main函数就返回这个元类型()，你不能说main函数无返回值，
    因为没有返回值的函数在Rust中是有单独的定义的：发散函数,顾名思义，无法收敛的函数.
    例如常见的println!()的返回值也是元类型()。

# rust中常见的数据类型
- 布尔型 - bool 表示 true 或 false
- 无符号整型- u8 u32 u64 u128 表示正整数
- 有符号整型 - i8 i32 i64 i128 表示正负整数
- 指针大小的整数 - usize isize 表示内存中内容的索引和大小
- 浮点数 - f32 f64
- 元组（tuple） - (value, value, ...) 用于在栈上传递固定序列的值
- 数组 - 在编译时已知的具有固定长度的相同元素的集合
- 切片（slice） - 在运行时已知长度的相同元素的集合
- str(string slice) - 在运行时已知长度的文本

```rust
fn main() {
    let x = 12; // 默认情况下，这是i32
    let a = 12u8;
    let b = 4.3; // 默认情况下，这是f64
    let c = 4.3f32;
    let bv = true;
    let t = (13, false);// 元组类型
    let sentence = "hello world!";
    println!(
        "{} {} {} {} {} {} {} {}",
        x, a, b, c, bv, t.0, t.1, sentence
    );
}
```
# 标量类型
    代表一个单独的值,rust有四种基本的标量类型： 整数、浮点型、布尔类型和字符类型

# isize和usize
- isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的，32 位架构上它们是 32 位的。
- Rust 的默认类型通常是个不错的起点，数字类型默认是 i32。
- isize 或 usize 主要作为某些集合的索引。

# f32和f64
- Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。
- 默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。
- 所有的浮点型都是有符号的。

# 语句和表达式
- 对于Rust语言而言，这种基于语句和表达式的方式是非常重要的，你需要能明确的区分这两个概念,但是对于很多其它语言而言，这两个往往无需区分。
- 基于表达式是函数式语言的重要特征，表达式总要返回值。
- 表达式会进行求值，然后返回一个值

# 类型推导

- Rust是一门静态类型语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为Rust编译器很聪明，
它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型。
- 同时编译器也不够聪明，在某些情况下，它无法推导出变量类型，需要手动去给予一个类型标注

# fn函数定义
函数要点
- 函数名和变量名使用蛇形命名法(snake case)，例如fn add_two() -> {}
- 函数的位置可以随便放，Rust不关心我们在哪里定义了函数，只要有定义即可
- 每个函数参数都需要标注类型

```rust
// 定义函数,->表示返回的标志，返回结果是一个i32类型
// x，y后面的: 接着指定类型
fn add(x: i32, y: i32) -> i32 {
    x + y // 这里rust中可以省略return直接将表达式作为结果返回
}

// 无返回值的函数定义
fn another_fn(x: i32) {
    println!("x = {x}");
}
// 元类型()，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：

// 函数没有返回值，那么返回一个()
// 通过;结尾的表达式返回一个()

// 永不返回任何东西
fn dead_end() -> ! {
    panic!("你已经到了穷途末路，崩溃吧！");
}

```

# 类型转换as
使用 as 关键字，Rust 使数字类型转换非常容易
```rust
fn main() {
    let a = 13u8;
    let b = 7u32;
    let c = a as u32 + b;
    println!("{}", c);

    let t = true;
    println!("{}", t as u8);
}
```

# 常量
- 常量允许我们高效地指定一个在代码中会被多次使用的公共值。不同于像变量一样在使用的时候会被复制，常量会在编译期间直接用它们的值来替换变量的文本标识符。
- 不同于变量，常量必须始终具有显式的类型
- 常量名遵循所有的字符全部大写，可以使用下划线进行分割
```rust
const PI: f32 = 3.14159;
const FOO_LEVEL : &str = "info";

fn main() {
    println!(
        "To make an apple {} from scratch, you must first create a universe.",
        PI
    );

    println!("FOO_LEVEL = {}",FOO_LEVEL);
}
```

# 数组
- 数组是所有相同类型数据元素的固定长度集合。
- 一个数组的数据类型是 [T;N]，其中 T 是元素的类型，N 是编译时已知的固定长度
- 通过下标index访问数组，其中 index 是所需元素的 usize 索引（从 0 开始）
```rust
fn main() {
    // 定义数组的类型和元素个数
    let nums: [i32; 3] = [1, 2, 3];
    println!("{:?}", nums);

    // 通过下标访问数组元素
    println!("{}", nums[1]);
}
```
